[{"categories":["Image Processing"],"contents":"Introduction The ColorChecker® Patch Classic target is an array of 24 scientifically prepared natural, chromatic, primary and gray scale colored squares in a wide range of colors. By positioning the ColorChecker in the test image, the resulting image\u0026rsquo;s output captured by cameras can be compared to the original chart (reference measurements).\nColorChecker Application To analyze images for color accuracy, white balance, SNR and ISO sensitivity. To color correct with the chart in the test pictures for camera\u0026rsquo;s image tuning. Reference: CIELAB values in illuminate D65 for The ColorChecker® Patch Classic\nColor Difference When it comes to Color Accuracy and Color Difference (error) Measurement, the most important essence is accurate color is not necessarily the same as pleasing color.\nHow to tune colors to make them more pleasing? By increasing Chroma (Saturation). With colorchecker to calculate the cameras\u0026rsquo;s image color error, we can substitute our own enhanced values.\nColor Difference are represented in CIELAB color space, where L* is luminance, a* is color on a green-red scale, and b* on a blue-yellow scale.\n1. Absolute Color Differences The absolute color difference is calculated with luminance. Since the CIELAB color space was designed to be relatively perceptually uniform, we can calculate the color difference by the method of calculating Eucliean distance (the formula below is the abosolute color difference CIE 1976): $$ ΔE*=\\sqrt{(L2* - L1*)^2+(a2*-a1*)^2+(b2*-b1*)^2} $$\n2. Chroma Differences The chroma difference is calculated without luminance. Since it is useful to look at color errors independently of exposure error, we define color differences that omit ΔL*: $$ ΔC*=\\sqrt{(a2*-a1*)^2+(b2*-b1*)^2}=\\sqrt{(ΔE*)^2+(L2*-L1*)^2} $$\nChroma Boost Chroma is the colorfulness of an area judged as a proportion of the brightness of a similarly illuminated area that appears white or highly transmitting. To correct colors for making them more pleasing, we need to boost chroma (saturation) to enhance image appearance in cameras.\nThe mean chroma percentage is calculated: $$ Chroma(％) = 100％ * \\frac{Measured\\quad\\sqrt{ai*^2+bi*^2}}{ColorChecker\\quad\\sqrt{ai*^2+bi*^2}} $$ The first three rows of the ColorChecker is calculated 1 ≤ i ≤ 18, the last row of the ColorChecker is not included in computing the mean chroma percentage.\nChroma, which is closely related to the perception of saturation, is boosted when Chroma(%) \u0026gt; 100. Chroma boost increases ΔE* and ΔC* color error measurements. Since it is easy to remove chroma boost in image editors (with saturation settings), it is useful to measure the color error after the mean chroma has been corrected (normalized) to 100%.\n","permalink":"https://NTUneillee.github.io/blog/chromatest/","tags":["Image Processing","Matlab","Image","Camera Tuning"],"title":"Camera Tuning Project: Chroma Test "},{"categories":["Signal Processing"],"contents":"Introduction The project is an Instrument Recognition Program with Matlab, featuring Time-Frequency Analysis method, Gabor Transform algorithm, Signal Feature Extraction, LBG Vector Quantization and K-means algorithm to achieve up to 80% recognition in musical instruments including Piano, Guitar, and Cello.\nLibrary library_cello1.mat, library_cello2.mat, library_cello3.mat, library_guitar1.mat, library_guitar2.mat, library_guitar3.mat, library_piano1.mat, library_piano2.mat, library_piano3.mat are the Libraries that I collected from thousnad of instrument music signals.\nProgram Code clear; close all; clc; [a, fs] = audioread(\u0026#39;music.wav\u0026#39;); segmentation = 5; % =================================================================== % Main Algorithm of Gabor Transform % =================================================================== x = a(:,1); tau = 0 : 1/44100 : 3.2; dt = 0.01; df = 1; t = 0 : dt : max(tau); f = 20 : df : 2500; sigma = 200; dt = t(2)-t(1); df = f(2)-f(1); dtau = tau(2)-tau(1); S = dt/dtau; C = length(t); F = length(f); T = length(tau); N = 1 / (df*dtau); B = 1.9143 / (sigma^(1/2)); Q = round( B/dtau ); n0 = tau(1) / dtau; c0 = t(1) / dt; m0 = f(1) / df; X = zeros(C,F); x1 = zeros(1,N); window = (sigma^(1/4)) * exp( -sigma*pi*( (Q-( 0:N-1 ))*dtau ).^2 ); for n = c0 :( c0+C-1 ) window_const = dtau * exp( (-1j*2*pi*( n*S-Q ) ) .* ( m0:(m0+F-1) )./N); for q = 0 : N-1 if ( (q\u0026lt;=(2*Q) ) \u0026amp;\u0026amp; ( n*S-Q+q\u0026gt;=0 ) \u0026amp;\u0026amp; ( n*S-Q+q+1\u0026lt;=T ) ) x1(q+1) = x( n*S-Q+q+1 ); else x1(q+1) = 0; end end X1 = fft( (window.*x1), N); X( (n-c0)+1, :) = window_const .* X1( m0+1 : ( (m0+F-1)+1 ) ); end y = X\u0026#39;; % =================================================================== % Convolution to g[n,m] and find Instantaneous Frequency % =================================================================== f0 = 20; L = (2*(f0/dt)); for n_ = 1:5 % n_ = n+3 for m_ = 1: (2*L+1) % m_ = L+(L+1) g(n_,m_) = exp(-(((m_-(L+1))*df)^2))/f0^2; end end Xs = conv2(abs(y),g\u0026#39;,\u0026#39;same\u0026#39;); % Create Threshold matrix of instantaneous frequency threshold_value = max(max(abs(Xs))) * 0.01; threshold = zeros(F,C); threshold = threshold + threshold_value; % Create Instantaneous Frequency zero matrix for later storing data InstantaneousFreq = zeros( size(Xs) ); for m = 1+1 : F-1 % to avoid reaching invalid index for n = 1 : C % find max frequency to become instantaneous frequency if ( Xs(m,n)\u0026gt;Xs(m-1,n) ) \u0026amp;\u0026amp; ( Xs(m,n)\u0026gt;Xs(m+1,n) ) \u0026amp;\u0026amp; ( abs((Xs(m,n))) \u0026gt; threshold(m,n) ) InstantaneousFreq(m,n) = 1; else InstantaneousFreq(m,n) = 0; end end end % =================================================================== % Connect [m,n] to create clear Instantaneous Frequency line % =================================================================== % create Clear Frequency data matrix for later operation ClearFrequency = []; for i = 1 : F % extract every frequency line row by row tmp = InstantaneousFreq(i,:); % identify the index of clear frequency line index = find( abs( real(tmp) ) \u0026gt; 0.0001 ); for j = 1 : C if ismember(j, index) % let the clear frequency line element to 1 tmp(j) = 1; else % remove the unclear frequemcy line tmp(j) = 0; end end % label the different region of clear frequemcy line tmp = bwlabel(tmp, 8); % find how many number of clear frequency line region tmp_max = max(tmp, [], \u0026#39;all\u0026#39;); for k = 1 : tmp_max if size( find( tmp==k ) ) \u0026lt; segmentation % Segmentation Variable tmp( find( tmp==k ) ) = 0; else tmp( find( tmp==k ) ) = 1; end end % store data in Clear Frequecny matrix ClearFrequency = [ ClearFrequency ; tmp ]; end % show the plot of siganl after Gabor Transform figure; image(t,f,abs(y)/max(max(abs(y)))*400)\tcolormap(gray(256))\tset(gca,\u0026#39;Ydir\u0026#39;,\u0026#39;normal\u0026#39;)\tset(gca,\u0026#39;Fontsize\u0026#39;,12)\txlabel(\u0026#39;Time (Sec)\u0026#39;,\u0026#39;Fontsize\u0026#39;,12)\tylabel(\u0026#39;Frequency (Hz)\u0026#39;,\u0026#39;Fontsize\u0026#39;,12)\t% show the plot of Instantaneous Frequency figure; image(t,f,abs(InstantaneousFreq)/max(max(abs(InstantaneousFreq)))*400)\tcolormap(gray(256))\tset(gca,\u0026#39;Ydir\u0026#39;,\u0026#39;normal\u0026#39;)\tset(gca,\u0026#39;Fontsize\u0026#39;,12)\txlabel(\u0026#39;Time (Sec)\u0026#39;,\u0026#39;Fontsize\u0026#39;,12)\tylabel(\u0026#39;Frequency (Hz)\u0026#39;,\u0026#39;Fontsize\u0026#39;,12)\t% show the plot of Clear Instantaneous Frequency figure; image(t,f,abs(ClearFrequency)/max(max(abs(ClearFrequency)))*400)\tcolormap(gray(256))\tset(gca,\u0026#39;Ydir\u0026#39;,\u0026#39;normal\u0026#39;)\tset(gca,\u0026#39;Fontsize\u0026#39;,12)\txlabel(\u0026#39;Time (Sec)\u0026#39;,\u0026#39;Fontsize\u0026#39;,12)\tylabel(\u0026#39;Frequency (Hz)\u0026#39;,\u0026#39;Fontsize\u0026#39;,12)\t% =================================================================== % Find the MAX time sample number of all instantaneous frequency % =================================================================== % create FreqTimeSample data matrix for later operation FreqTimeSample = []; % label the different region of clear frequemcy line ClearFrequency_label = bwlabel( ClearFrequency, 8 ); % find how many number of clear frequency line region label_max = max(ClearFrequency_label, [], \u0026#39;all\u0026#39;); for i = 1 : label_max % find the number of time sample of every instantaneous frequency FreqTimeSample_tmp = size( find(ClearFrequency_label == i) , 1); % store data in FreqTimeSample matrix FreqTimeSample = [ FreqTimeSample FreqTimeSample_tmp ]; end % find the MAX time sample number of instantaneous frequency MAX_FreqTimeSample = max(FreqTimeSample); % =================================================================== % Find Real Frequency Value and its Time data of all frequency % =================================================================== % create Real Frequency Value data matrix for later operation RealFreqValue = []; % TimeRange will lose 1 data after sampling (round down) MaxSampleNum = MAX_FreqTimeSample - 1; % initial setting of Time Data for all time sample of frequency TimeData = zeros(label_max, MaxSampleNum); % initial setting of Frequency Value Data for all time sample of frequency % indexes of FreqValueData are correspond to its TimeData FreqValueData = zeros(label_max , MaxSampleNum); [ row, column ] = size(ClearFrequency); for i = 1 : label_max [r, c] = find( ClearFrequency_label == i ); % calculate the Real Frequency Value of Instaneous frequency FreqValue = mean(r) + 20; % correction coefficient ylim [20 1001] % store data in Real Frequency Value matrix RealFreqValue = [ RealFreqValue FreqValue ]; % calculate the Real Time Value of every sample and find its min and max c_min = min(c) * (1.6/column); c_max = max(c) * (1.6/column); % TimeRange store the data of all time sample for all Freq region TimeRange = [ c_min : dt : c_max ]; for k = 1 : size( TimeRange,2 ) % how many time sample in this region TimeData(i,k) = TimeRange(k); FreqValueData(i,k) = FreqValue; end end % =================================================================== % Find frequency energy ratio of all primary frequency region % =================================================================== E1_set = []; E2_set = []; E3_set = []; EnergyRatioE2E1_set = []; EnergyRatioE3E1_set = []; E_onset_set = []; E_offset_set = []; E_all_set =[]; EnergyRatioOn_set = []; EnergyRatioOff_set = []; for FrequencyRegion = 1 : label_max y_value = (abs(y)).^2; [r, c] = find( ClearFrequency_label == FrequencyRegion ); fmin1 = 0.5 * RealFreqValue(FrequencyRegion); fmax1 = 1.5 * RealFreqValue(FrequencyRegion); min_row1 = round(fmin1) - 20; max_row1 = round(fmax1) - 20; if min_row1 \u0026lt; 1 min_row1 = 1; elseif max_row1 \u0026gt; F max_row1 = F; end E1 = sum( y_value( min_row1 : max_row1 , min(c) : max(c) ) , \u0026#39;all\u0026#39;); E1_set = [ E1_set E1 ]; fmin2 = 1.5 * RealFreqValue(FrequencyRegion); fmax2 = 2.5 * RealFreqValue(FrequencyRegion); min_row2 = round(fmin2) - 20; max_row2 = round(fmax2) - 20; if min_row2 \u0026lt; 1 min_row2 = 1; elseif max_row2 \u0026gt; F max_row2 = F; end E2 = sum( y_value( min_row2 : max_row2 , min(c) : max(c) ) , \u0026#39;all\u0026#39;); E2_set = [ E2_set E2 ]; fmin3 = 2.5 * RealFreqValue(FrequencyRegion); fmax3 = 3.5 * RealFreqValue(FrequencyRegion); min_row3 = round(fmin3) - 20; max_row3 = round(fmax3) - 20; if min_row3 \u0026lt; 1 min_row3 = 1; elseif max_row3 \u0026gt; F max_row3 = F; end ​ E3 = sum( y_value( min_row3 : max_row3 , min(c) : max(c) ) , \u0026#39;all\u0026#39;); ​ E3_set = [ E3_set E3 ]; ​ ​ EnergyRatioE2E1 = E2 / E1; ​ EnergyRatioE2E1_set = [ EnergyRatioE2E1_set EnergyRatioE2E1 ]; ​ ​ EnergyRatioE3E1 = E3 / E1; ​ EnergyRatioE3E1_set = [ EnergyRatioE3E1_set EnergyRatioE3E1 ]; ​ ​ begin_all = min(c); ​ finish_all = max(c); ​ begin_onset = min(c); ​ finish_onset = min(c) + round(( (max(c)-min(c)) * 0.1 )); ​ begin_offset = min(c) + round(( (max(c)-min(c)) * 0.9 )); ​ finish_offset = max(c); ​ ​ LowLimit = round( ( RealFreqValue(FrequencyRegion) -20 ) - 5 ); ​ HighLimit = round( ( RealFreqValue(FrequencyRegion) -20 ) + 5 ); ​ ​ if ( LowLimit \u0026lt; 1 ) ​ LowLimit = 1; ​ elseif (HighLimit \u0026gt; F ) ​ HighLimit = F; ​ end ​ ​ E_onset = sum( y_value( LowLimit:HighLimit, begin_onset:finish_onset ) , \u0026#39;all\u0026#39;); ​ E_onset_set = [ E_onset_set E_onset ]; ​ ​ E_offset = sum( y_value( LowLimit:HighLimit, begin_offset:finish_offset ) , \u0026#39;all\u0026#39;); ​ E_offset_set = [ E_offset_set E_offset ]; ​ ​ E_all = sum( y_value( LowLimit:HighLimit, begin_all:finish_all ) , \u0026#39;all\u0026#39;); ​ E_all_set =[ E_all_set E_all ]; ​ ​ EnergyRatioOn = E_onset / E_all; ​ EnergyRatioOn_set = [ EnergyRatioOn_set EnergyRatioOn ]; ​ ​ EnergyRatioOff = E_offset / E_all; ​ EnergyRatioOff_set = [ EnergyRatioOff_set EnergyRatioOff ]; ​ end % =================================================================== % Find error between Real Frequency \u0026amp; its second-order approximation % =================================================================== % create error data matrix of each frequency region for later operation error_set = []; for FrequencyRegion = 1 : label_max % create Frequency column vector data of every sample point B = []; ​ for i = 1 : MaxSampleNum ​ ​ % extract the TimeData of every sample point row by row ​ n_FreqTimeSample = TimeData( FrequencyRegion, : ); ​ % find B = [ m m*n m*n^2 ]\u0026#39; column vector for approximation ​ B_tmp = RealFreqValue( FrequencyRegion ) * n_FreqTimeSample(i) .^ (0:2); ​ ​ % the element of B_tmp that not exist is time = 0 ​ if ( B_tmp(2) == 0 ) \u0026amp;\u0026amp; ( B_tmp(3) == 0) ​ B_tmp(1) = 0; ​ end ​ % change the element of not exist B_tmp become zero column vector ​ ​ B = [ B B_tmp\u0026#39;]; ​ ​ end ​ ​ % create approximation coefficient for every sample point ​ S = []; ​ for i = 1 : MaxSampleNum ​ ​ % extract the Frequemcy data of every region column by column ​ B_column = B(:,i); ​ ​ % create A matrix for second-order approximation ​ for n = 1:3 ​ for m = 1:3 ​ for k = 1:3 ​ A(m,k) = ( n_FreqTimeSample(i) )^( m+k-2 ); ​ end ​ end ​ end ​ ​ % lower precision for lower computation ​ A = round(A,1); ​ % inverse A matrix for calculate approximation coefficient ​ S_tmp = pinv(A) * B_column; ​ S = [S S_tmp]; ​ ​ end ​ % create approzimation B of each frequency region for later operation ​ B_approximation_set= []; ​ ​ for i = 1 : MaxSampleNum ​ ​ % extract the Coefficient data of every region column by column ​ S_column = S(:,i); ​ ​ % create A matrix for second-order approximation ​ for n = 1:3 ​ for m = 1:3 ​ for k = 1:3 ​ A(m,k) = ( n_FreqTimeSample(i) )^( m+k-2 ); ​ end ​ end ​ end ​ ​ % approximate the frequency of each time samplefor each region ​ B_approximation_matrix = A*S_column; ​ B_approximation_set = [ B_approximation_set B_approximation_matrix ]; ​ ​ end ​ ​ for i = 1 : MaxSampleNum ​ ​ % some sample point does not exist so its B_approximation will be 0 ​ % convert 0 to eps to avoid later operation problem (0/0=InF) ​ if ( B_approximation_set(1,i) == 0 ) ​ B_approximation_set(1,i) = eps; ​ end ​ ​ % some frequency point does not exist so its Freq data will be 0 ​ % convert 0 to eps to avoid later operation problem (0/0=InF) ​ if ( FreqValueData(FrequencyRegion,i) == 0 ) ​ FreqValueData(FrequencyRegion,i) = eps; ​ end ​ ​ end ​ ​ % extract the data of approximation frequency we need in the first row ​ B_approximation = B_approximation_set(1,:); ​ % extract the data of real frequency we need row by row ​ FreqValueData_row = FreqValueData(FrequencyRegion,:); ​ ​ % calculate error data row by row for each region ​ error = sum(abs((B_approximation-FreqValueData_row) ./ FreqValueData_row)) / (MaxSampleNum); ​ error_percentage = round( error*100, 2 ); ​ ​ error_set = [ error_set error_percentage ]; end % find total error for all frequency region total_error = sum(error_set)/size(error_set,2); AllData = [ RealFreqValue ; EnergyRatioE2E1_set ; EnergyRatioE3E1_set; ... EnergyRatioOn_set ; EnergyRatioOff_set ; error_set ] HighFreqE2E1 = []; HighFreqE3E1 = []; HighFreqOn = []; HighFreqOff = []; HighFreqError = []; MiddleFreqE2E1 = []; MiddleFreqE3E1 = []; MiddleFreqOn = []; MiddleFreqOff = []; MiddleFreqError = []; LowFreqE2E1 = []; LowFreqE3E1 = []; LowFreqOn = []; LowFreqOff = []; LowFreqError = []; for i = 1 : label_max if AllData(1,i) \u0026gt; 1000 HighFreqE2E1 = [ HighFreqE2E1 AllData(2,i) ]; HighFreqE3E1 = [ HighFreqE3E1 AllData(3,i) ]; HighFreqOn = [ HighFreqOn AllData(4,i) ] ; HighFreqOff = [ HighFreqOff AllData(5,i) ]; HighFreqError = [ HighFreqError AllData(6,i) ]; elseif AllData(1,i) \u0026lt; 500 LowFreqE2E1 = [ LowFreqE2E1 AllData(2,i) ]; LowFreqE3E1 = [ LowFreqE3E1 AllData(3,i) ]; LowFreqOn = [ LowFreqOn AllData(4,i) ] ; LowFreqOff = [ LowFreqOff AllData(5,i) ]; LowFreqError = [ LowFreqError AllData(6,i) ]; else MiddleFreqE2E1 = [ MiddleFreqE2E1 AllData(2,i) ]; MiddleFreqE3E1 = [ MiddleFreqE3E1 AllData(3,i) ]; MiddleFreqOn = [ MiddleFreqOn AllData(4,i) ] ; MiddleFreqOff = [ MiddleFreqOff AllData(5,i) ]; MiddleFreqError = [ MiddleFreqError AllData(6,i) ]; end end MeanValue1 = 0; HighFreqE2E1_sort_set = []; for i = 1 : size( HighFreqE2E1, 2 ) HighFreqE2E1_sort = sort( HighFreqE2E1 ); if HighFreqE2E1_sort(:,i) \u0026lt; 2 MeanValue1 = ( MeanValue1*(i-1) + HighFreqE2E1_sort(:,i) )/i; else HighFreqE2E1_sort(:,i) = MeanValue1; end HighFreqE2E1_sort_set = [ HighFreqE2E1_sort_set HighFreqE2E1_sort(i) ]; end MeanValue2 = 0; HighFreqE3E1_sort_set = []; for i = 1 : size( HighFreqE3E1, 2 ) HighFreqE3E1_sort = sort( HighFreqE3E1 ); if HighFreqE3E1_sort(:,i) \u0026lt; 2 MeanValue2 = ( MeanValue2*(i-1) + HighFreqE3E1_sort(:,i) )/i; else HighFreqE3E1_sort(:,i) = MeanValue1; end HighFreqE3E1_sort_set = [ HighFreqE3E1_sort_set HighFreqE3E1_sort(i) ]; end MeanValue3 = 0; HighFreqOn_sort_set = []; for i = 1 : size( HighFreqOn, 2 ) HighFreqOn_sort = sort( HighFreqOn ); if HighFreqOn_sort(:,i) \u0026lt; 2 MeanValue3 = ( MeanValue3*(i-1) + HighFreqOn_sort(:,i) )/i; else HighFreqOn_sort(:,i) = MeanValue3; end HighFreqOn_sort_set = [ HighFreqOn_sort_set HighFreqOn_sort(i) ]; end MeanValue4 = 0; HighFreqOff_sort_set = []; for i = 1 : size( HighFreqOff, 2 ) HighFreqOff_sort = sort( HighFreqOff ); if HighFreqOff_sort(:,i) \u0026lt; 2 MeanValue4 = ( MeanValue4*(i-1) + HighFreqOff_sort(:,i) )/i; else HighFreqOff_sort(:,i) = MeanValue4; end HighFreqOff_sort_set = [ HighFreqOff_sort_set HighFreqOff_sort(i) ]; end MeanValue5 = 0; HighFreqError_sort_set = []; for i = 1 : size( HighFreqError, 2 ) HighFreqError_sort = sort( HighFreqError ); if HighFreqError_sort(i) \u0026lt; 10 MeanValue5 = ( MeanValue5*(i-1) + HighFreqError_sort(i) )/i; else HighFreqError_sort(i) = MeanValue5; end HighFreqError_sort_set = [ HighFreqError_sort_set HighFreqError_sort(i) ]; end MeanValue6 = 0; MiddleFreqE2E1_sort_set = []; for i = 1 : size( MiddleFreqE2E1, 2 ) MiddleFreqE2E1_sort = sort( MiddleFreqE2E1 ); if MiddleFreqE2E1_sort(:,i) \u0026lt; 2 MeanValue6 = ( MeanValue6*(i-1) + MiddleFreqE2E1_sort(:,i) )/i; else MiddleFreqE2E1_sort(:,i) = MeanValue1; end MiddleFreqE2E1_sort_set = [ MiddleFreqE2E1_sort_set MiddleFreqE2E1_sort(i) ]; end MeanValue7 = 0; MiddleFreqE3E1_sort_set = []; for i = 1 : size( MiddleFreqE3E1, 2 ) MiddleFreqE3E1_sort = sort( MiddleFreqE3E1 ); if MiddleFreqE3E1_sort(:,i) \u0026lt; 2 MeanValue7 = ( MeanValue7*(i-1) + MiddleFreqE3E1_sort(:,i) )/i; else MiddleFreqE3E1_sort(:,i) = MeanValue7; end MiddleFreqE3E1_sort_set = [ MiddleFreqE3E1_sort_set MiddleFreqE3E1_sort(i) ]; end MeanValue8 = 0; MiddleFreqOn_sort_set = []; for i = 1 : size( MiddleFreqOn, 2 ) MiddleFreqOn_sort = sort( MiddleFreqOn ); if MiddleFreqOn_sort(:,i) \u0026lt; 2 MeanValue8 = ( MeanValue8*(i-1) + MiddleFreqOn_sort(:,i) )/i; else MiddleFreqOn_sort(:,i) = MeanValue8; end MiddleFreqOn_sort_set = [ MiddleFreqOn_sort_set MiddleFreqOn_sort(i) ]; end MeanValue9 = 0; MiddleFreqOff_sort_set = []; for i = 1 : size( MiddleFreqOff, 2 ) MiddleFreqOff_sort = sort( MiddleFreqOff ); if MiddleFreqOff_sort(:,i) \u0026lt; 2 MeanValue9 = ( MeanValue9*(i-1) + MiddleFreqOff_sort(:,i) )/i; else MiddleFreqOff_sort(:,i) = MeanValue9; end MiddleFreqOff_sort_set = [ MiddleFreqOff_sort_set MiddleFreqOff_sort(i) ]; end MeanValue10 = 0; MiddleFreqError_sort_set = []; for i = 1 : size( MiddleFreqError, 2 ) MiddleFreqError_sort = sort( MiddleFreqError ); if MiddleFreqError_sort(i) \u0026lt; 10 MeanValue10 = ( MeanValue10*(i-1) + MiddleFreqError_sort(i) )/i; else MiddleFreqError_sort(i) = MeanValue10; end MiddleFreqError_sort_set = [ MiddleFreqError_sort_set MiddleFreqError_sort(i) ]; end MeanValue11 = 0; LowFreqE2E1_sort_set = []; for i = 1 : size( LowFreqE2E1, 2 ) LowFreqE2E1_sort = sort( LowFreqE2E1 ); if LowFreqE2E1_sort(:,i) \u0026lt; 2 MeanValue11 = ( MeanValue11*(i-1) + LowFreqE2E1_sort(:,i) )/i; else LowFreqE2E1_sort(:,i) = MeanValue11; end LowFreqE2E1_sort_set = [ LowFreqE2E1_sort_set LowFreqE2E1_sort(i) ]; end MeanValue12 = 0; LowFreqE3E1_sort_set = []; for i = 1 : size( LowFreqE3E1, 2 ) LowFreqE3E1_sort = sort( LowFreqE3E1 ); if LowFreqE3E1_sort(:,i) \u0026lt; 2 MeanValue12 = ( MeanValue12*(i-1) + LowFreqE3E1_sort(:,i) )/i; else LowFreqE3E1_sort(:,i) = MeanValue12; end LowFreqE3E1_sort_set = [ LowFreqE3E1_sort_set LowFreqE3E1_sort(i) ]; end MeanValue13 = 0; LowFreqOn_sort_set = []; for i = 1 : size( LowFreqOn, 2 ) LowFreqOn_sort = sort( LowFreqOn ); if LowFreqOn_sort(:,i) \u0026lt; 2 MeanValue13 = ( MeanValue13*(i-1) + LowFreqOn_sort(:,i) )/i; else lowFreqOn_sort(:,i) = MeanValue13; end LowFreqOn_sort_set = [ LowFreqOn_sort_set LowFreqOn_sort(i) ]; end MeanValue14 = 0; LowFreqOff_sort_set = []; for i = 1 : size( LowFreqOff, 2 ) LowFreqOff_sort = sort( LowFreqOff ); if LowFreqOff_sort(:,i) \u0026lt; 2 MeanValue14 = ( MeanValue14*(i-1) + LowFreqOff_sort(:,i) )/i; else LowFreqOff_sort(:,i) = MeanValue14; end LowFreqOff_sort_set = [ LowFreqOff_sort_set LowFreqOff_sort(i) ]; end MeanValue15 = 0; LowFreqError_sort_set = []; for i = 1 : size( LowFreqError, 2 ) LowFreqError_sort = sort( LowFreqError ); if LowFreqError_sort(i) \u0026lt; 10 MeanValue15 = ( MeanValue15*(i-1) + LowFreqError_sort(i) )/i; else LowFreqError_sort(i) = MeanValue15; end LowFreqError_sort_set = [ LowFreqError_sort_set LowFreqError_sort(i) ]; end HighFreqE2E1_mean = mean( HighFreqE2E1_sort_set ) HighFreqE3E1_mean = mean( HighFreqE3E1_sort_set ) HighFreqOn_mean = mean( HighFreqOn_sort_set ) HighFreqOff_mean = mean( HighFreqOff_sort_set ) HighFreqError_mean = mean( HighFreqError_sort_set ) MiddleFreqE2E1_mean = mean( MiddleFreqE2E1_sort_set ) MiddleFreqE3E1_mean = mean( MiddleFreqE3E1_sort_set ) MiddleFreqOn_mean = mean( MiddleFreqOn_sort_set ) MiddleFreqOff_mean = mean( MiddleFreqOff_sort_set ) MiddleFreqError_mean = mean( MiddleFreqError_sort_set ) LowFreqE2E1_mean = mean( LowFreqE2E1_sort_set ) LowFreqE3E1_mean = mean( LowFreqE3E1_sort_set ) LowFreqOn_mean = mean( LowFreqOn_sort_set ) LowFreqOff_mean = mean( LowFreqOff_sort_set ) LowFreqError_mean = mean( LowFreqError_sort_set ) SignalFeature = [ HighFreqE2E1_mean, HighFreqE3E1_mean, ... HighFreqOn_mean, HighFreqOff_mean, HighFreqError_mean, ... MiddleFreqE2E1_mean, MiddleFreqE3E1_mean, ... MiddleFreqOn_mean, MiddleFreqOff_mean, MiddleFreqError_mean, ... LowFreqE2E1_mean, LowFreqE3E1_mean, ... LowFreqOn_mean, LowFreqOff_mean, LowFreqError_mean ] SignalFeature_kmeans = lbgVQ( SignalFeature, 4); load(\u0026#39;library_cello1.mat\u0026#39;) d1_set = []; for i = 1 : size(library_cello1,3) d1(i) = distanceEu( SignalFeature, library_cello1(:,:,i) ); d1_set = [ d1_set d1(i) ]; end d1_data = sum( d1_set )/size(library_cello1,3); load(\u0026#39;library_cello2.mat\u0026#39;) d2_set = []; for i = 1 : size(library_cello2,3) d2(i) = distanceEu( SignalFeature, library_cello2(:,:,i) ); d2_set = [ d2_set d2(i) ]; end d2_data = sum( d2_set )/size(library_cello2,3); load(\u0026#39;library_guitar1.mat\u0026#39;) d3_set = []; for i = 1 : size(library_guitar1,3) d3(i) = distanceEu( SignalFeature, library_guitar1(:,:,i) ); d3_set = [ d3_set d3(i) ]; end d3_data = sum( d3_set )/size(library_guitar1,3); load(\u0026#39;library_guitar2.mat\u0026#39;) d4_set = []; for i = 1 : size(library_guitar2,3) d4(i) = distanceEu( SignalFeature, library_guitar2(:,:,i) ); d4_set = [ d4_set d4(i) ]; end d4_data = sum( d4_set )/size(library_guitar2,3); load(\u0026#39;library_guitar3.mat\u0026#39;) d5_set = []; for i = 1 : size(library_guitar3,3) d5(i) = distanceEu( SignalFeature, library_guitar3(:,:,i) ); d5_set = [ d5_set d5(i) ]; end d5_data = sum( d5_set )/size(library_guitar3,3); load(\u0026#39;library_piano1.mat\u0026#39;) d6_set = []; for i = 1 : size(library_piano1,3) d6(i) = distanceEu( SignalFeature, library_piano1(:,:,i) ); d6_set = [ d6_set d6(i) ]; end d6_data = sum( d6_set )/size(library_piano1,3); load(\u0026#39;library_piano2.mat\u0026#39;) d7_set = []; for i = 1 : size(library_piano2,3) d7(i) = distanceEu( SignalFeature, library_piano2(:,:,i) ); d7_set = [ d7_set d7(i) ]; end d7_data = sum( d7_set )/size(library_piano2,3); load(\u0026#39;library_piano3.mat\u0026#39;) % electro piano d8_set = []; for i = 1 : size(library_piano3,3) d8(i) = distanceEu( SignalFeature, library_piano3(:,:,i) ); d8_set = [ d8_set d8(i) ]; end d8_data = sum( d8_set )/size(library_piano3,3); % Recoginition RecogData = [ d1_data d2_data d3_data d4_data d5_data d6_data d7_data d8_data ] if ( min( RecogData ) == d1_data ) || ( min( RecogData ) == d2_data ) fprintf(\u0026#39;The signal is Cello. \u0026#39;) elseif ( min( RecogData ) == d3_data ) || ( min( RecogData ) == d4_data ) || ( min( RecogData ) == d5_data ) fprintf(\u0026#39;The signal is Guitar. \u0026#39;) elseif ( min( RecogData ) == d6_data ) || ( min( RecogData ) == d7_data ) || ( min( RecogData ) == d8_data ) fprintf(\u0026#39;The signal is Piano. \u0026#39;) end ","permalink":"https://NTUneillee.github.io/blog/instrumenctrec/","tags":["Signal Processing","Matlab","Time Frequency Analysis"],"title":" Music Instrument Recognition Project"},{"categories":["Signal Processing"],"contents":"Introduction The project is an Instrument Recognition Program with Matlab, featuring Time-Frequency Analysis method, Gabor Transform algorithm, Signal Feature Extraction, LBG Vector Quantization and K-means algorithm to achieve up to 80% recognition in musical instruments including Piano, Guitar, and Cello.\nfunction note = KeyGenerate(KeyNumber,tempo,beat,fs) % Set the t-axis of a note and the sampling interval 1/fs t = [0 : 1/fs : (60/tempo)*beat]; % The equation gives the frequency f of the nth key number f = 440 * 2^( (KeyNumber-49)/12 ); % Simulate the tone quality by \u0026#34;triangle decreasing\u0026#34; middle = ( t(1)+t(end) )/2; triangle = middle - abs(t-middle); triangle = triangle ./ max(triangle); % Using sin(2*pi*f*t) to be the basis of tone quality note = (sin(2*pi*f*t)).*triangle; end function MusicSynthesis() name = input(\u0026#39;Music Name: \u0026#39;,\u0026#34;s\u0026#34;); fs = input(\u0026#39;Sampling Rate fs: \u0026#39;); % Tempo: Lento 60, Adagio 80, Moderato 100, Allegro 120 tempo = input(\u0026#39;Tempo(60, 80, 100, 120): \u0026#39;); % Generate all the paino notes with 1 and 2 beat La0_1 = KeyGenerate( 1, tempo, 1, fs); La0_2 = KeyGenerate( 1, tempo, 2, fs); % A0 La_0_1 = KeyGenerate( 2, tempo, 1, fs); La_0_2 = KeyGenerate( 2, tempo, 2, fs); % A#0 Si0_1 = KeyGenerate( 3, tempo, 1, fs); Si0_2 = KeyGenerate( 3, tempo, 2, fs); % B0 Do0_1 = KeyGenerate( 4, tempo, 1, fs); Do0_2 = KeyGenerate( 4, tempo, 2, fs); % C0 Do_0_1 = KeyGenerate( 5, tempo, 1, fs); Do_0_2 = KeyGenerate( 5, tempo, 2, fs); % C#0 Re0_1 = KeyGenerate( 6, tempo, 1, fs); Re0_2 = KeyGenerate( 6, tempo, 2, fs); % D0 Re_0_1 = KeyGenerate( 7, tempo, 1, fs); Re_0_2 = KeyGenerate( 7, tempo, 2, fs); % D#0 Mi0_1 = KeyGenerate( 8, tempo, 1, fs); Mi0_2 = KeyGenerate( 8, tempo, 2, fs); % E0 Fa0_1 = KeyGenerate( 9, tempo, 1, fs); Fa0_2 = KeyGenerate( 9, tempo, 2, fs); % F0 Fa_0_1 = KeyGenerate(10, tempo, 1, fs); Fa_0_2 = KeyGenerate(10, tempo, 2, fs); % F#0 So0_1 = KeyGenerate(11, tempo, 1, fs); So0_2 = KeyGenerate(11, tempo, 2, fs); % G0 So_0_1 = KeyGenerate(12, tempo, 1, fs); So_0_2 = KeyGenerate(12, tempo, 2, fs); % G#0 La1_1 = KeyGenerate(13, tempo, 1, fs); La1_2 = KeyGenerate(13, tempo, 2, fs); % A1 La_1_1 = KeyGenerate(14, tempo, 1, fs); La_1_2 = KeyGenerate(14, tempo, 2, fs); % A#1 Si1_1 = KeyGenerate(15, tempo, 1, fs); Si1_2 = KeyGenerate(15, tempo, 2, fs); % B1 Do1_1 = KeyGenerate(16, tempo, 1, fs); Do1_2 = KeyGenerate(16, tempo, 2, fs); % C1 Do_1_1 = KeyGenerate(17, tempo, 1, fs); Do_1_2 = KeyGenerate(17, tempo, 2, fs); % C#1 Re1_1 = KeyGenerate(18, tempo, 1, fs); Re1_2 = KeyGenerate(18, tempo, 2, fs); % D1 Re_1_1 = KeyGenerate(19, tempo, 1, fs); Re_1_2 = KeyGenerate(19, tempo, 2, fs); % D#1 Mi1_1 = KeyGenerate(20, tempo, 1, fs); Mi1_2 = KeyGenerate(20, tempo, 2, fs); % E1 Fa1_1 = KeyGenerate(21, tempo, 1, fs); Fa1_2 = KeyGenerate(21, tempo, 2, fs); % F1 Fa_1_1 = KeyGenerate(22, tempo, 1, fs); Fa_1_2 = KeyGenerate(22, tempo, 2, fs); % F#1 So1_1 = KeyGenerate(23, tempo, 1, fs); So1_2 = KeyGenerate(23, tempo, 2, fs); % G1 So_1_1 = KeyGenerate(24, tempo, 1, fs); So_1_2 = KeyGenerate(24, tempo, 2, fs); % G#1 La2_1 = KeyGenerate(25, tempo, 1, fs); La2_2 = KeyGenerate(25, tempo, 2, fs); % A2 La_2_1 = KeyGenerate(26, tempo, 1, fs); La_2_2 = KeyGenerate(26, tempo, 2, fs); % A#2 Si2_1 = KeyGenerate(27, tempo, 1, fs); Si2_2 = KeyGenerate(27, tempo, 2, fs); % B2 Do2_1 = KeyGenerate(28, tempo, 1, fs); Do2_2 = KeyGenerate(28, tempo, 2, fs); % C2 Do_2_1 = KeyGenerate(29, tempo, 1, fs); Do_2_2 = KeyGenerate(29, tempo, 2, fs); % C#2 Re2_1 = KeyGenerate(30, tempo, 1, fs); Re2_2 = KeyGenerate(30, tempo, 2, fs); % D2 Re_2_1 = KeyGenerate(31, tempo, 1, fs); Re_2_2 = KeyGenerate(31, tempo, 2, fs); % D#2 Mi2_1 = KeyGenerate(32, tempo, 1, fs); Mi2_2 = KeyGenerate(32, tempo, 2, fs); % E2 Fa2_1 = KeyGenerate(33, tempo, 1, fs); Fa2_2 = KeyGenerate(33, tempo, 2, fs); % F2 Fa_2_1 = KeyGenerate(34, tempo, 1, fs); Fa_2_2 = KeyGenerate(34, tempo, 2, fs); % F#2 So2_1 = KeyGenerate(35, tempo, 1, fs); So2_2 = KeyGenerate(35, tempo, 2, fs); % G2 So_2_1 = KeyGenerate(36, tempo, 1, fs); So_2_2 = KeyGenerate(36, tempo, 2, fs); % G#2 La3_1 = KeyGenerate(37, tempo, 1, fs); La3_2 = KeyGenerate(37, tempo, 2, fs); % A3 La_3_1 = KeyGenerate(38, tempo, 1, fs); La_3_2 = KeyGenerate(38, tempo, 2, fs); % A#3 Si3_1 = KeyGenerate(39, tempo, 1, fs); Si3_2 = KeyGenerate(39, tempo, 2, fs); % B3 Do3_1 = KeyGenerate(40, tempo, 1, fs); Do3_2 = KeyGenerate(40, tempo, 2, fs); % C3 Do_3_1 = KeyGenerate(41, tempo, 1, fs); Do_3_2 = KeyGenerate(41, tempo, 2, fs); % C#3 Re3_1 = KeyGenerate(42, tempo, 1, fs); Re3_2 = KeyGenerate(42, tempo, 2, fs); % D3 Re_3_1 = KeyGenerate(43, tempo, 1, fs); Re_3_2 = KeyGenerate(43, tempo, 2, fs); % D#3 Mi3_1 = KeyGenerate(44, tempo, 1, fs); Mi3_2 = KeyGenerate(44, tempo, 2, fs); % E3 Fa3_1 = KeyGenerate(45, tempo, 1, fs); Fa3_2 = KeyGenerate(45, tempo, 2, fs); % F3 Fa_3_1 = KeyGenerate(46, tempo, 1, fs); Fa_3_2 = KeyGenerate(46, tempo, 2, fs); % F#3 So3_1 = KeyGenerate(47, tempo, 1, fs); So3_2 = KeyGenerate(47, tempo, 2, fs); % G3 So_3_1 = KeyGenerate(48, tempo, 1, fs); So_3_2 = KeyGenerate(48, tempo, 2, fs); % G#3 La4_1 = KeyGenerate(49, tempo, 1, fs); La4_2 = KeyGenerate(49, tempo, 2, fs); % A4 La_4_1 = KeyGenerate(50, tempo, 1, fs); La_4_2 = KeyGenerate(50, tempo, 2, fs); % A#4 Si4_1 = KeyGenerate(51, tempo, 1, fs); Si4_2 = KeyGenerate(51, tempo, 2, fs); % B4 Do4_1 = KeyGenerate(52, tempo, 1, fs); Do4_2 = KeyGenerate(52, tempo, 2, fs); % C4 # middle C Do_4_1 = KeyGenerate(53, tempo, 1, fs); Do_4_2 = KeyGenerate(53, tempo, 2, fs); % C#4 Re4_1 = KeyGenerate(54, tempo, 1, fs); Re4_2 = KeyGenerate(54, tempo, 2, fs); % D4 Re_4_1 = KeyGenerate(55, tempo, 1, fs); Re_4_2 = KeyGenerate(55, tempo, 2, fs); % D#4 Mi4_1 = KeyGenerate(56, tempo, 1, fs); Mi4_2 = KeyGenerate(56, tempo, 2, fs); % E4 Fa4_1 = KeyGenerate(57, tempo, 1, fs); Fa4_2 = KeyGenerate(57, tempo, 2, fs); % F4 Fa_4_1 = KeyGenerate(58, tempo, 1, fs); Fa_4_2 = KeyGenerate(58, tempo, 2, fs); % F#4 So4_1 = KeyGenerate(59, tempo, 1, fs); So4_2 = KeyGenerate(59, tempo, 2, fs); % G4 So_4_1 = KeyGenerate(60, tempo, 1, fs); So_4_2 = KeyGenerate(60, tempo, 2, fs); % G#4 La5_1 = KeyGenerate(61, tempo, 1, fs); La5_2 = KeyGenerate(61, tempo, 2, fs); % A5 La_5_1 = KeyGenerate(62, tempo, 1, fs); La_5_2 = KeyGenerate(62, tempo, 2, fs); % A#5 Si5_1 = KeyGenerate(63, tempo, 1, fs); Si5_2 = KeyGenerate(63, tempo, 2, fs); % B5 Do5_1 = KeyGenerate(64, tempo, 1, fs); Do5_2 = KeyGenerate(64, tempo, 2, fs); % C5 Do_5_1 = KeyGenerate(65, tempo, 1, fs); Do_5_2 = KeyGenerate(65, tempo, 2, fs); % C#5 Re5_1 = KeyGenerate(66, tempo, 1, fs); Re5_2 = KeyGenerate(66, tempo, 2, fs); % D5 Re_5_1 = KeyGenerate(67, tempo, 1, fs); Re_5_2 = KeyGenerate(67, tempo, 2, fs); % D#5 Mi5_1 = KeyGenerate(68, tempo, 1, fs); Mi5_2 = KeyGenerate(68, tempo, 2, fs); % E5 Fa5_1 = KeyGenerate(69, tempo, 1, fs); Fa5_2 = KeyGenerate(69, tempo, 2, fs); % F5 Fa_5_1 = KeyGenerate(70, tempo, 1, fs); Fa_5_2 = KeyGenerate(70, tempo, 2, fs); % F#5 So5_1 = KeyGenerate(71, tempo, 1, fs); So5_2 = KeyGenerate(71, tempo, 2, fs); % G5 So_5_1 = KeyGenerate(72, tempo, 1, fs); So_5_2 = KeyGenerate(72, tempo, 2, fs); % G#5 La6_1 = KeyGenerate(73, tempo, 1, fs); La6_2 = KeyGenerate(73, tempo, 2, fs); % A6 La_6_1 = KeyGenerate(74, tempo, 1, fs); La_6_2 = KeyGenerate(74, tempo, 2, fs); % A#6 Si6_1 = KeyGenerate(75, tempo, 1, fs); Si6_2 = KeyGenerate(75, tempo, 2, fs); % B6 Do6_1 = KeyGenerate(76, tempo, 1, fs); Do6_2 = KeyGenerate(76, tempo, 2, fs); % C6 Do_6_1 = KeyGenerate(77, tempo, 1, fs); Do_6_2 = KeyGenerate(77, tempo, 2, fs); % C#6 Re6_1 = KeyGenerate(78, tempo, 1, fs); Re6_2 = KeyGenerate(78, tempo, 2, fs); % D6 Re_6_1 = KeyGenerate(79, tempo, 1, fs); Re_6_2 = KeyGenerate(79, tempo, 2, fs); % D#6 Mi6_1 = KeyGenerate(80, tempo, 1, fs); Mi6_2 = KeyGenerate(80, tempo, 2, fs); % E6 Fa6_1 = KeyGenerate(81, tempo, 1, fs); Fa6_2 = KeyGenerate(81, tempo, 2, fs); % F6 Fa_6_1 = KeyGenerate(82, tempo, 1, fs); Fa_6_2 = KeyGenerate(82, tempo, 2, fs); % F#6 So6_1 = KeyGenerate(83, tempo, 1, fs); So6_2 = KeyGenerate(83, tempo, 2, fs); % G6 So_6_1 = KeyGenerate(84, tempo, 1, fs); So_6_2 = KeyGenerate(84, tempo, 2, fs); % G#6 La7_1 = KeyGenerate(85, tempo, 1, fs); La7_2 = KeyGenerate(85, tempo, 2, fs); % A7 La_7_1 = KeyGenerate(86, tempo, 1, fs); La_7_2 = KeyGenerate(86, tempo, 2, fs); % A#7 Si7_1 = KeyGenerate(87, tempo, 1, fs); Si7_2 = KeyGenerate(87, tempo, 2, fs); % B7 Do7_1 = KeyGenerate(88, tempo, 1, fs); Do7_2 = KeyGenerate(88, tempo, 2, fs); % C7 Do_7_1 = KeyGenerate(89, tempo, 1, fs); Do_7_2 = KeyGenerate(89, tempo, 2, fs); % C#7 Re7_1 = KeyGenerate(90, tempo, 1, fs); Re7_2 = KeyGenerate(90, tempo, 2, fs); % D7 Re_7_1 = KeyGenerate(91, tempo, 1, fs); Re_7_2 = KeyGenerate(91, tempo, 2, fs); % D#7 Mi7_1 = KeyGenerate(92, tempo, 1, fs); Mi7_2 = KeyGenerate(92, tempo, 2, fs); % E7 Fa7_1 = KeyGenerate(93, tempo, 1, fs); Fa7_2 = KeyGenerate(93, tempo, 2, fs); % F7 Fa_7_1 = KeyGenerate(94, tempo, 1, fs); Fa_7_2 = KeyGenerate(94, tempo, 2, fs); % F#7 So7_1 = KeyGenerate(95, tempo, 1, fs); So7_2 = KeyGenerate(95, tempo, 2, fs); % G7 So_7_1 = KeyGenerate(96, tempo, 1, fs); So_7_2 = KeyGenerate(96, tempo, 2, fs); % G#7 La8_1 = KeyGenerate( 97, tempo, 1, fs); La8_2 = KeyGenerate( 97, tempo, 2, fs); % A8 La_8_1 = KeyGenerate( 98, tempo, 1, fs); La_8_2 = KeyGenerate( 98, tempo, 2, fs); % A#8 Si8_1 = KeyGenerate( 99, tempo, 1, fs); Si8_2 = KeyGenerate( 99, tempo, 2, fs); % B8 Do8_1 = KeyGenerate(100, tempo, 1, fs); Do8_2 = KeyGenerate(100, tempo, 2, fs); % C8 Do_8_1 = KeyGenerate(101, tempo, 1, fs); Do_8_2 = KeyGenerate(101, tempo, 2, fs); % C#8 Re8_1 = KeyGenerate(102, tempo, 1, fs); Re8_2 = KeyGenerate(102, tempo, 2, fs); % D8 Re_8_1 = KeyGenerate(103, tempo, 1, fs); Re_8_2 = KeyGenerate(103, tempo, 2, fs); % D#8 Mi8_1 = KeyGenerate(104, tempo, 1, fs); Mi8_2 = KeyGenerate(104, tempo, 2, fs); % E8 Fa8_1 = KeyGenerate(105, tempo, 1, fs); Fa8_2 = KeyGenerate(105, tempo, 2, fs); % F8 Fa_8_1 = KeyGenerate(106, tempo, 1, fs); Fa_8_2 = KeyGenerate(106, tempo, 2, fs); % F#8 So8_1 = KeyGenerate(107, tempo, 1, fs); So8_2 = KeyGenerate(107, tempo, 2, fs); % G8 So_8_1 = KeyGenerate(108, tempo, 1, fs); So_8_2 = KeyGenerate(108, tempo, 2, fs); % G#8 La4_0 = KeyGenerate(49, tempo, 1/2, fs); La4_2 = KeyGenerate(49, tempo, 2, fs); % A4 La_4_0 = KeyGenerate(50, tempo, 1/2, fs); La_4_2 = KeyGenerate(50, tempo, 2, fs); % A#4 Si4_0 = KeyGenerate(51, tempo, 1/2, fs); Si4_2 = KeyGenerate(51, tempo, 2, fs); % B4 Do4_0 = KeyGenerate(52, tempo, 1/2, fs); Do4_2 = KeyGenerate(52, tempo, 2, fs); % C4 # middle C Do_4_0 = KeyGenerate(53, tempo, 1/2, fs); Do_4_2 = KeyGenerate(53, tempo, 2, fs); % C#4 Re4_0 = KeyGenerate(54, tempo, 1/2, fs); Re4_2 = KeyGenerate(54, tempo, 2, fs); % D4 Re_4_0 = KeyGenerate(55, tempo, 1/2, fs); Re_4_2 = KeyGenerate(55, tempo, 2, fs); % D#4 Mi4_0 = KeyGenerate(56, tempo, 1/2, fs); Mi4_2 = KeyGenerate(56, tempo, 2, fs); % E4 Fa4_0 = KeyGenerate(57, tempo, 1/2, fs); Fa4_2 = KeyGenerate(57, tempo, 2, fs); % F4 Fa_4_0 = KeyGenerate(58, tempo, 1/2, fs); Fa_4_2 = KeyGenerate(58, tempo, 2, fs); % F#4 So4_0 = KeyGenerate(59, tempo, 1/2, fs); So4_2 = KeyGenerate(59, tempo, 2, fs); % G4 So_4_0 = KeyGenerate(60, tempo, 1/2, fs); So_4_2 = KeyGenerate(60, tempo, 2, fs); % G#4 La5_0 = KeyGenerate(61, tempo, 1/2, fs); La5_2 = KeyGenerate(61, tempo, 2, fs); % A5 La_5_0 = KeyGenerate(62, tempo, 1/2, fs); La_5_2 = KeyGenerate(62, tempo, 2, fs); % A#5 Si5_0 = KeyGenerate(63, tempo, 1/2, fs); Si5_2 = KeyGenerate(63, tempo, 2, fs); % B5 Do5_0 = KeyGenerate(64, tempo, 1/2, fs); Do5_2 = KeyGenerate(64, tempo, 2, fs); % C5 Do_5_0 = KeyGenerate(65, tempo, 1/2, fs); Do_5_2 = KeyGenerate(65, tempo, 2, fs); % C#5 Re5_0 = KeyGenerate(66, tempo, 1/2, fs); Re5_2 = KeyGenerate(66, tempo, 2, fs); % D5 Re_5_0 = KeyGenerate(67, tempo, 1/2, fs); Re_5_2 = KeyGenerate(67, tempo, 2, fs); % D#5 Mi5_0 = KeyGenerate(68, tempo, 1/2, fs); Mi5_2 = KeyGenerate(68, tempo, 2, fs); % E5 Fa5_0 = KeyGenerate(69, tempo, 1/2, fs); Fa5_2 = KeyGenerate(69, tempo, 2, fs); % F5 Fa_5_0 = KeyGenerate(70, tempo, 1/2, fs); Fa_5_2 = KeyGenerate(70, tempo, 2, fs); % F#5 So5_0 = KeyGenerate(71, tempo, 1/2, fs); So5_2 = KeyGenerate(71, tempo, 2, fs); % G5 So_5_0 = KeyGenerate(72, tempo, 1/2, fs); So_5_2 = KeyGenerate(72, tempo, 2, fs); % G#5 Fa4_01 = KeyGenerate(57, tempo, 3/4, fs); Re_4_01 = KeyGenerate(55, tempo, 1/4, fs); So4_4 = KeyGenerate(59, tempo, 4, fs); Re_4_4 = KeyGenerate(55, tempo, 4, fs); Fa4_4 = KeyGenerate(57, tempo, 4, fs); % Attack on titan: The Rumbling song = [ Re_4_0, Fa4_0, So_4_1, So4_0, So4_2, So_4_0, La_5_1, Fa4_2, ... Fa4_0, Re_4_0, Fa4_0, Re_4_0, Fa4_0, So4_0, So4_4 ... Re_4_0, Fa4_0, So_4_1, So4_0, So4_2, So_4_1, So4_0, So4_2, Fa4_1, Re_4_0, Re_4_4, ... Re_4_0, Fa4_0, So_4_1, So4_0, So4_2, So_4_0, La_5_1, Fa4_2, ... Fa4_0, Re_4_0, Fa4_0, Re_4_0, Fa4_0, So4_0, So4_4, ... Fa4_0, Re_4_0, Fa4_0, Re_4_0, Fa4_1, Re_4_0, Fa4_1, Re_4_0, Fa4_1, Fa_4_1, Fa4_4, ... So4_1, Do4_2, So4_1, Do4_2, Do4_0, La_5_1, So_4_1, So4_1, Do4_2, So4_1, Do4_0, So4_0, So4_1]; sound(song, fs); audiowrite(strcat(name, \u0026#39;.wav\u0026#39;), song, fs); end ","permalink":"https://NTUneillee.github.io/blog/musicsynthesis/","tags":["Signal Processing","Matlab","Music"],"title":"Basic Music Synthesis Project"},{"categories":["Image Processing"],"contents":"Introduction Image quality can be assessed using objective or subjective methods. In the objective method, image quality assessments are performed by different algorithms that analyze the distortions and degradations introduced in an image. Subjective image quality assessments are a method based on the way in which humans experience or perceive image quality.\nParticularily, objective image quality assessments are the most important topic that we are currently focused on in image processing applications. Image Quality analysis consist of two objective IQ metric: Full Reference Image quality Assessment (FR-IQA) and No Reference Image Quality Assessment (NR-IQA).\nFR-IQA: To assess the quality of a test image by comparing it with a reference image NR-IQA: To assess the quality of a test image without any reference to the original one An image quality metric can play a variety of roles in image processing applications: to dynamically monitor and adjust image quality, optimize algorithm and parameter settings of image processing system and to benchmark the image processing system, parameter setting and algorithm.\nYCbCr color space In the following introduction of PSNR and SSIM image quality metric, the images are undergo a pre-processing stage: RGB to YCbCr conversion. The RGB to YCbCr conversion can seperate the luma and chroma component of an image.\nY luminance component: the brightness of the color. Cb chrominance component: the blue component relative to the green. Cr chrominance component: the blue component relative to the green. Why can we get rid of the Green component in this color space? Because Green is the color that our human eyes are most semsitive to, Green is naturally included as part of the Luminance Component!\nBesides, studies show that human eyes are way more sensitive to luminance instead of chrominance. YCbCr color space ensures that we can achieve a more appealing representation of scenes and images.\nYCbCr is a scaled and offset version of the YUV color space: YUV is an analog system. YCbCr is a digital system. However, they are used interchangeably in the general sense.\nPSNR To measure the difference of the two signals (including images, videos, and vocal signals), Maximal Error, Mean Square Error, Normalized Mean Square Error and Normalized Root Mean Square Error are the most easier measurment method. The idea of PSNR is derived from MSE.\nPeak signal-to-noise ratio (PSNR) is the ratio between the maximum possible power of a siganl and the power of corrupting noise that affects the fidelity of its representation. PSNR is usually expressed as a logarithmic quantity using the db scale because many signals have a very wide dynamic range.\nPSNR definition PSNR index is defined by Mean Square Error (MSE). Suppose x[m,n] is the reference image and the y[m,n] is the test image, then MSE is represented by the equation below: $$ MSE = \\frac{1}{MN}\\sum_{i=0}^{M-1}\\sum_{j=0}^{N-1}\\left|y[m,n]-x[m,n]\\right|^2 $$ Consequently, PSNR is represented by\n$$ PSNR = 10·log{_1}{_0}{ \\left(\\frac{X{_m}{_a}{_x}^2}{MSE}\\right)}=20·log{_1}{_0}{ \\left(\\frac{X{_m}{_a}{_x}}{\\sqrt{MSE}}\\right)} $$ When the samples are represented with 8 bits per sample, Xmax is 255, the maximum pixel value in the image. More generally, when samples are represented with B bits per sample, Xmax is (2^B)-1 in the formula.\nPSNR code TestImage = imread(\u0026#39;test.jpg\u0026#39;); NoiseImage = imnoise(TestImage); figure; imshow(TestImage); figure; imshow(NoiseImage); % if size(image,3) == 1, then the image is gray scale % convert the image to double-precision array directly if size(TestImage,3) == 1 y1 = double(TestImage); y2 = double(NoiseImage); end % if size(image,3) == 1, then the image is gray scale % convert the image from RGB to YCbCr to get luminance if size(TestImage,3) == 3 TestImage_new = rgb2ycbcr(TestImage); NoiseImage_new = rgb2ycbcr(NoiseImage); % the luminance component is in the first array LuminanceTest = TestImage_new(:,:,1); LuminanceNoise = NoiseImage_new(:,:,1); % then convert the image to double-precision array y1 = double(LuminanceTest); y2 = double(LuminanceNoise); end % the difference of two signals difference = y2 - y1; % array(:) convert all the array into a column vector % array(:) .* array(:) can calculate dot for 2 array % prod(size(array)) get the sum of array index MSE = sum( difference(:) .* difference(:)) / prod(size(difference) ); % calculate PSNR, Xmax = 255 in an image psnr = 10 * log10( 255^2 / MSE ) PSNR disadvantages However, PSNR index cannot really well matched to the human perceived visual quality. The following images below are Picture 1, Picture 2, and Picture 3, respectively.\nReference: Jian-Jiun Ding, Advanced Digital SIgnal Processing class note, the Department of Electrical Engineering, National Taiwan University (NTU), Taipei, Taiwan.\nLogically speaking, Picture 1 and Picture 3 are more similar, but the MSE between Picture 1 and 2 is 0.4411, and the MSE between Picture 1 and 3 is 0.4460. Consequently, PSNR image quality assessment has its limitation.\nSSIM Every pixel of natural image carries important information about the structure of the objects in the visual scenes. The motivation of new approach is to find a more direct way to compare the structures of the “reference image” and the \u0026ldquo;test image”.\nBecause the human visual system is highly adapted to extract structure information from the viewing field, Structure Similarity Metric (SSIM) turns out to be an important metric that quantifies image quality compared to a reference image. The similarity measurement is separated into three components: Luminance, Contrast and Structure.\nThe luminance is estimated as mean intensity The contrast is estimated as standard deviations The structure is estimated by normalized standard deviations SSIM actually measures the perceptual difference between two similar images. It cannot judge which of the two is better, but it can provide some benchmark analysis information (the quality of contrast in the test image compared to the reference).\nSSIM definition SSIM index is calculated between two windows x and y by the following algorithm: $$ SSIM = \\left(\\frac{2μ{_x}μ{_y}+c{_1}}{ μ{_x}^2+ μ{_y}^2+c{_1}}\\right)\\left(\\frac{2σ{_x}σ{_y}+c{_2}}{σ{_x}^2+σ{_y}^2+c{_2}}\\right) $$\nμx, μy: means of x and y / σx, σy: variances of x and y σxy: covariance of x and y / c1, c2: adjustable constant parameters L: ( the maximal possible value of x ) - ( the minimal possible value if x ) = 255 SSIM component There are three comparison measuremtent between the reference image (x) and the test image (y) in the SSIM algorithm: Luminance (l), Contrast (c), structure (s): $$ l(x,y) = \\frac{2μ{_x}μ{_y}+(c{_1}L)^2}{ μ{_x}^2+ μ{_y}^2+(c{_1}L)^2}, \\quad c(x,y) = \\frac{2σ{_x}σ{_y}+(c{_2}L)^2}{σ{_x}^2+σ{_y}^2+(c{_2}L)^2}, \\quad s(x,y) = \\frac{σ{_x}{_y}+(c{_3}L)^2}{σ{_x}σ{_y}+(c{_3}L)^2} $$ SSIM is the weighted combination of these three components, by setting their weights to the same, the SSIM formula the can be simplified to the form shown above.\nSSIM code clear; close all; clc; ReferenceImage = imread(\u0026#39;reference.jpg\u0026#39;); TestImage = imread(\u0026#39;test.jpg\u0026#39;); % Set the size of Test Image equal to Reference Image % ================================================================ TestRow = size(TestImage,1); TestColumn = size(TestImage,2); TestRow_modified = size(ReferenceImage, 1); TestColumn_modified = size(ReferenceImage, 2); % Create (x,y) pairs for each point in the image and define its coordinate % X-axis: the number of column / Y-axis: the number of row % [ column, row ] = meshgrid( 1 : column, 1 : row ) [n1, m1] = meshgrid(1 : TestColumn_modified, 1 : TestRow_modified); % Let Sm = m / m\u0026#39; and let m = m\u0026#39; * Sm for m = 1,...,m\u0026#39; Sm = TestRow / TestRow_modified; m1 = m1 * Sm; % Let Sn = n / n\u0026#39; Let nf = c\u0026#39; * Sn for n = 1,...,n\u0026#39; Sn = TestColumn / TestColumn_modified; n1 = n1 * Sn; % Let m = round(m1) and n = round(n1) m = round(m1); n = round(n1); % Setting the values out of range m(m \u0026lt; 1) = 1; n(n \u0026lt; 1) = 1; m(m \u0026gt; TestRow - 1) = TestRow - 1; n(n \u0026gt; TestColumn - 1) = TestColumn - 1; % Setting delta_m = m1 - m, delta_n = n1 - n delta_m = m1 - m; delta_n = n1 - n; % Get indices for each point we wish to access Test1_index = sub2ind([TestRow, TestColumn], m, n); Test2_index = sub2ind([TestRow, TestColumn], m+1, n); Test3_index = sub2ind([TestRow, TestColumn], m, n+1); Test4_index = sub2ind([TestRow, TestColumn], m+1, n+1); % Interpolate: Go through each channel for the case of colour % Create output image that is the same class as input ModifiedTestImage = zeros(TestRow_modified, TestColumn_modified, size(TestImage, 3)); ModifiedTestImage = cast(ModifiedTestImage, class(TestImage)); for index = 1 : size(TestImage, 3) % Get i\u0026#39;th channel to get its color matrix channel = double(TestImage(:,:,index)); % Interpolate the channel tmp = channel(Test1_index) .* (1 - delta_m) .* (1 - delta_n) + ... channel(Test2_index) .* (delta_m) .* (1 - delta_n) + ... channel(Test3_index) .* (1 - delta_m) .* (delta_n) + ... channel(Test4_index) .* (delta_m) .* (delta_n); ModifiedTestImage(:,:,index) = cast(tmp, class(TestImage)); end % Implement the algorithm of SSIM % =============================================================== c1 = input(\u0026#39;c1: \u0026#39;); % recommand: c1 = 0.01 c2 = input(\u0026#39;c2: \u0026#39;); % recommand: c2 = 0.03 % if size(image,3) == 1, then the image is gray scale % convert the image to double-precision array directly if size(ReferenceImage,3) == 1 x = double(ReferenceImage); end if size(ModifiedTestImage,3) == 1 y = double(ModifiedTestImage); end % if size(image,3) == 1, then the image is gray scale % convert the image from RGB to YCbCr to get luminance if size(ReferenceImage,3) == 3 ReferenceImage_new = rgb2ycbcr(ReferenceImage); % the luminance component is in the first array LuminanceReference = ReferenceImage_new(:,:,1); % then convert the image to double-precision array x = double(LuminanceReference); end if size(ModifiedTestImage,3) == 3 TestImage_new = rgb2ycbcr(ModifiedTestImage); % the luminance component is in the first array LuminanceTest = TestImage_new(:,:,1); % then convert the image to double-precision array y = double(LuminanceTest); end mean_x = sum(sqrt( x(:).*x(:) )) / prod(size(x)); mean_y = sum(sqrt( y(:).*y(:) )) / prod(size(y)); Xdiff = x - mean_x; variance_x = sqrt( sum( Xdiff(:).*Xdiff(:) ) / prod(size(x) ) ); Ydiff = y - mean_y; variance_y = sqrt( sum( Ydiff(:).*Ydiff(:) ) / prod(size(y) ) ); variance_xy = sum( Xdiff(:).*Ydiff(:) ) / prod(size(x) ); L = 255; Component1 = ( 2*mean_x*mean_y + (c1*L)^2 ) / ( mean_x^2+mean_y^2 + (c1*L)^2 ); Component2 = ( 2*variance_xy + (c2*L)^2 ) / ( variance_x^2 + variance_y^2 + (c2*L)^2 ); imshow(ReferenceImage) imshow(ModifiedTestImage) luminance_component = ( 2*mean_x*mean_y + (c1*L)^2 ) / ( mean_x^2+mean_y^2 + (c1*L)^2 ) contrast_component = ( 2*variance_xy + (c2*L)^2 ) / ( variance_x^2 + variance_y^2 + (c2*L)^2 ) SSIM = Component1*Component2 Benchmark Analysis Here are 8 pictures photographed using the same scene. Each picture has the same luminance and structure but different contrast information. By setting luminance and structure parameters of the reference and the test image to an approximate identity, we can use the SSIM index to objectively compare the contrast quality between them.\ncontrast+80 (image 1)\ncontrast+60 (image 2)\ncontrast+40 (image 3)\ncontrast+20 (image 4)\ncontrast 0 (image 5)\ncontrast-20 (image 6)\ncontrast-40 (image 7)\ncontrast-60 (image 8)\ncontrast-60 (image 9)\nBenchmark Analysis Result Because \u0026ldquo;image 5\u0026rdquo; (contrast 0) seems like the picture with the greatest contrast for our human visual system, let\u0026rsquo;s take \u0026ldquo;image 5\u0026rdquo; (contrast 0) as the reference image for this SSIM benchmark analysis.\nIn order to rank each picture\u0026rsquo;s contrast quality, this project is assessed and benchmarked by SSIM index.\n1 vs 5 2 vs 5 3 vs 5 4 vs 5 6 vs 5 7 vs 5 8 vs 5 9 vs 5 l(x,y) 0.9995 0.9997 0.9998 1.0000 1.0000 0.9999 0.9997 0.9996 c(x,y) 0.9473 0.9669 0.9832 0.9946 0.9937 0.9773 0.9468 0.9017 SSIM 0.9468 0.9665 0.9831 0.9946 0.9936 0.9772 0.9465 0.9013 Based on the data shown above, we can assume that the contrast quality ranking, from good to bad, becomes image 4, 6, 3, 7, 2, 1, 8, 5.\nSSIM disadvantages SSIM is limited when the images has unstructured distortion. It is sensitive to image rotations and image translations. If we are using SSIM index for competitor analysis and trying to compare images where both camera\u0026rsquo;s FOV (field of view) are slightly different, then it\u0026rsquo;ll leads to erroneous image quality measurements.\n","permalink":"https://NTUneillee.github.io/blog/psnrvsssim/","tags":["Image Processing","Matlab","Image"],"title":"PSNR and SSIM"}]
<!doctype html>
<html lang="en-US">
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=59073&amp;path=livereload" data-no-instant defer></script>
        <meta charset="utf-8" />
        <meta name="description" content="Image Quality Assessment implementation" />
        <meta property="og:title" content="PSNR and SSIM" />
        <meta property="og:description" content="Image Quality Assessment implementation" />
        <meta property="og:url" content="http://localhost:59073/research/psnrvsssim/" />
        
        <meta property="og:image" content="http://localhost:59073/images/post/imagequality.jpg" />
        
        <meta property="og:image:width" content="1200" />
        <meta property="og:image:height" content="630" />

        <meta name="twitter:title" content="PSNR and SSIM" />
        <meta name="twitter:description" content="Image Quality Assessment implementation" />
        
        <meta name="twitter:image" content="http://localhost:59073/images/post/imagequality.jpg" />
        
        <meta name="twitter:card" content="summary_large_image" />
        <meta name="keywords" content="Image Processing, Matlab, Image" />
        <title>PSNR and SSIM</title>

        <link href="https://fonts.googleapis.com/css?family=Google+Sans|Noto+Sans|Castoro" rel="stylesheet" />

        <link rel="stylesheet" href="http://localhost:59073/academic-assets/css/spf-bulma.min.css" />
        <link rel="stylesheet" href="http://localhost:59073/academic-assets/css/fontawesome.all.min.css" />
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.5/css/academicons.min.css" integrity="sha256-SzrCOBJbGVFMahewkgjwnApaV2+av1DwMAA+/QGLyZw=" crossorigin="anonymous" />
        <link rel="stylesheet" href="http://localhost:59073/academic-assets/css/spf-index.css" />

        <script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js" integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
        <script defer src="http://localhost:59073/academic-assets/js/fontawesome.all.min.js"></script>

        <script>
            window.MathJax = {
                tex: {
                    inlineMath: [["$", "$"]],
                },
            };
        </script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@4.0.0/tex-mml-chtml.js" integrity="sha256-qoRlVrS5NAnXSSSiMfFXwK8C9obG11Iybe4h2+bQYR4=" crossorigin="anonymous"></script>

        <style>
            .back-to-research {
                position: fixed;
                top: 20px;
                left: 20px;
                z-index: 1000;
                background: hsl(204, 86%, 53%);
                color: white;
                padding: 10px 20px;
                border-radius: 6px;
                text-decoration: none;
                font-weight: 600;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                transition: all 0.3s ease;
                font-family: "Google Sans", sans-serif;
            }
            .back-to-research:hover {
                background: hsl(204, 86%, 45%);
                color: white;
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            }
            .back-to-research i {
                margin-right: 8px;
            }
        </style>
    </head>

    <body>
        <a href="http://localhost:59073/research" class="back-to-research">
            <i class="fas fa-arrow-left"></i>
            Back to Research
        </a>

        <section class="hero">
            <div class="hero-body">
                <div class="container is-max-desktop">
                    <div class="columns is-centered">
                        <div class="column has-text-centered">
                            <h1 class="title is-1 publication-title">
                                PSNR and SSIM
                            </h1>
                            

                            <div class="is-size-5 publication-authors">
                                
                                <span class="author-block">
                                    <a href="http://localhost:59073/" target="_blank">Neil Lee</a>
                                </span>
                                
                            </div>

                            <div class="is-size-5 publication-authors">
                                
                                <span class="author-block">Yuan-Kang Lee<br />2022</span>
                                

                                
                            </div>

                            <div class="column has-text-centered">
                                <div class="publication-links">
                                    

                                    

                                    

                                    
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section class="hero teaser">
            <div class="container is-max-desktop">
                <div class="hero-body">
                    
                    <img src="http://localhost:59073/images/post/imagequality.jpg" alt="PSNR and SSIM" />
                    
                    <h2 class="subtitle has-text-centered">
                        Image Quality Assessment implementation
                    </h2>
                </div>
            </div>
        </section>

        <section class="section hero is-light">
            <div class="container is-max-desktop">
                <div class="columns is-centered has-text-centered">
                    <div class="column is-four-fifths">
                        <h2 class="title is-3">Abstract</h2>
                        <div class="content has-text-justified">
                            <h2 id="introduction">Introduction</h2>
<blockquote>
<p><strong>Image quality</strong> can be assessed using objective or subjective methods. In the objective method, image quality assessments are performed by different algorithms that analyze the distortions and degradations introduced in an image. Subjective image quality assessments are a method based on the way in which humans experience or perceive image quality.</p>
</blockquote>
<p>Particularily, objective image quality assessments are the most important topic that we are currently focused on in image processing applications. Image Quality analysis consist of two objective IQ metric: Full Reference Image quality Assessment (FR-IQA) and No Reference Image Quality Assessment (NR-IQA).</p>
<ul>
<li><strong>FR-IQA</strong>: To assess the quality of a test image by comparing it with a reference image</li>
<li><strong>NR-IQA</strong>: To assess the quality of a test image without any reference to the original one</li>
</ul>
<p>An image quality metric can play a variety of roles in image processing applications: to dynamically monitor and adjust image quality, optimize algorithm and parameter settings of image processing system and to benchmark the image processing system, parameter setting and algorithm.</p>
<h2 id="ycbcr-color-space">YCbCr color space</h2>
<blockquote>
<p>In the following introduction of PSNR and SSIM image quality metric, the images are undergo a pre-processing stage: RGB to YCbCr conversion. The RGB to YCbCr conversion can seperate the luma and chroma component of an image.</p>
</blockquote>
<ul>
<li><strong>Y luminance component</strong>:  the brightness of the color.</li>
<li><strong>Cb chrominance component</strong>: the blue component relative to the green.</li>
<li><strong>Cr chrominance component</strong>: the blue component relative to the green.</li>
</ul>
<p>Why can we get rid of the Green component in this color space? Because <strong>Green is the color that our human eyes are most semsitive to</strong>, Green is naturally included as part of the Luminance Component!</p>
<p>Besides, studies show that <strong>human eyes are way more sensitive to luminance instead of chrominance.</strong> YCbCr color space ensures that we can achieve a more appealing representation of scenes and images.</p>
<p><img src="/images/post/YUV1.png" alt="YUV.png"></p>
<p><em>YCbCr is a scaled and offset version of the YUV color space: YUV is an analog system. YCbCr is a digital system. However, they are used interchangeably in the general sense.</em></p>
<h2 id="psnr">PSNR</h2>
<blockquote>
<p>To measure the difference of the two signals (including images, videos, and vocal signals), Maximal Error, Mean Square Error, Normalized Mean Square Error and Normalized Root Mean Square Error are the most easier measurment method. The idea of PSNR is derived from MSE.</p>
</blockquote>
<p><strong>Peak signal-to-noise ratio</strong> (<strong>PSNR</strong>) is the ratio between the maximum possible power of a siganl and the power of corrupting noise that affects the fidelity of its representation. PSNR is usually expressed as a logarithmic quantity using the db scale because many signals have a very wide dynamic range.</p>
<h3 id="psnr-definition">PSNR definition</h3>
<p>PSNR index is defined by Mean Square Error (MSE). Suppose x[m,n] is the reference image and the y[m,n] is the test image, then MSE is represented by the equation below:
$$
MSE = \frac{1}{MN}\sum_{i=0}^{M-1}\sum_{j=0}^{N-1}\left|y[m,n]-x[m,n]\right|^2
$$
Consequently, PSNR is represented by</p>
<p>$$
PSNR = 10·log{_1}{_0}{ \left(\frac{X{_m}{_a}{_x}^2}{MSE}\right)}=20·log{_1}{_0}{ \left(\frac{X{_m}{_a}{_x}}{\sqrt{MSE}}\right)}
$$
When the samples are represented with 8 bits per sample,  X<!-- raw HTML omitted -->max<!-- raw HTML omitted --> is 255, the maximum pixel value in the image. More generally, when samples are represented with B bits per sample, X<!-- raw HTML omitted -->max<!-- raw HTML omitted --> is (2^B)-1 in the formula.</p>
<h3 id="psnr-code">PSNR code</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-matlab" data-lang="matlab"><span style="display:flex;"><span>TestImage = imread(<span style="color:#e6db74">&#39;test.jpg&#39;</span>);
</span></span><span style="display:flex;"><span>NoiseImage = imnoise(TestImage);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>figure; imshow(TestImage);
</span></span><span style="display:flex;"><span>figure; imshow(NoiseImage);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">% if size(image,3) == 1, then the image is gray scale</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">% convert the image to double-precision array directly</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> size(TestImage,<span style="color:#ae81ff">3</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>            
</span></span><span style="display:flex;"><span>    y1 = double(TestImage); 
</span></span><span style="display:flex;"><span>    y2 = double(NoiseImage);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">% if size(image,3) == 1, then the image is gray scale</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">% convert the image from RGB to YCbCr to get luminance </span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> size(TestImage,<span style="color:#ae81ff">3</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span>   
</span></span><span style="display:flex;"><span>    TestImage_new = rgb2ycbcr(TestImage);
</span></span><span style="display:flex;"><span>    NoiseImage_new = rgb2ycbcr(NoiseImage);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">% the luminance component is in the first array</span>
</span></span><span style="display:flex;"><span>    LuminanceTest = TestImage_new(:,:,<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    LuminanceNoise = NoiseImage_new(:,:,<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">% then convert the image to double-precision array </span>
</span></span><span style="display:flex;"><span>    y1 = double(LuminanceTest);  
</span></span><span style="display:flex;"><span>    y2 = double(LuminanceNoise);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">% the difference of two signals </span>
</span></span><span style="display:flex;"><span>difference = y2 <span style="color:#f92672">-</span> y1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">% array(:) convert all the array into a column vector</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">% array(:) .* array(:) can calculate dot for 2 array</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">% prod(size(array)) get the sum of array index  </span>
</span></span><span style="display:flex;"><span>MSE = sum( difference(:) <span style="color:#f92672">.*</span> difference(:)) <span style="color:#f92672">/</span> prod(size(difference) );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">% calculate PSNR, Xmax = 255 in an image</span>
</span></span><span style="display:flex;"><span>psnr = <span style="color:#ae81ff">10</span> <span style="color:#f92672">*</span> log10( <span style="color:#ae81ff">255</span>^<span style="color:#ae81ff">2</span> <span style="color:#f92672">/</span> MSE )
</span></span></code></pre></div><h3 id="psnr-disadvantages">PSNR disadvantages</h3>
<p>However, PSNR index cannot really well matched to the human perceived visual quality. The following images below are Picture 1, Picture 2, and Picture 3, respectively.</p>
<p><img src="/images/post/PSNR.jpg" alt="PSNR.jpg"></p>
<p><em>Reference: Jian-Jiun Ding, Advanced Digital SIgnal Processing class note, the Department of Electrical Engineering, National Taiwan University (NTU), Taipei, Taiwan.</em></p>
<p>Logically speaking, Picture 1 and Picture 3 are more similar, but the MSE between Picture 1 and 2 is <strong>0.4411</strong>, and the MSE between Picture 1 and 3 is <strong>0.4460</strong>. Consequently, PSNR image quality assessment has its limitation.</p>
<h2 id="ssim">SSIM</h2>
<blockquote>
<p>Every pixel of natural image carries important information about the structure of the objects in the visual scenes. The motivation of new approach is to find a more direct way to compare the structures of the “reference image” and the &ldquo;test image”.</p>
</blockquote>
<p>Because the human visual system is highly adapted to extract structure information from the viewing field,  <strong>Structure Similarity Metric</strong> (SSIM) turns out to be an important metric that quantifies image quality compared to a reference image. The similarity measurement is separated into three components: <strong>Luminance</strong>, <strong>Contrast</strong> and <strong>Structure</strong>.</p>
<ul>
<li>The luminance is estimated as <em>mean intensity</em></li>
<li>The contrast is estimated as <em>standard deviations</em></li>
<li>The structure is estimated by <em>normalized standard deviations</em></li>
</ul>
<p>SSIM actually measures the <strong>perceptual difference</strong> between two similar images. It cannot judge which of the two is better, but it can provide some benchmark analysis information (the quality of contrast in the test image compared to the reference).</p>
<h3 id="ssim-definition">SSIM definition</h3>
<p>SSIM index is calculated between two windows x and y by the following algorithm:
$$
SSIM = \left(\frac{2μ{_x}μ{_y}+c{_1}}{ μ{_x}^2+ μ{_y}^2+c{_1}}\right)\left(\frac{2σ{_x}σ{_y}+c{_2}}{σ{_x}^2+σ{_y}^2+c{_2}}\right)
$$</p>
<ol>
<li>μx, μy: means of x and y  /  σx, σy: variances of x and y</li>
<li>σxy: covariance of x and y  / c1, c2: adjustable constant parameters</li>
<li>L: ( the maximal possible value of x ) - ( the minimal possible value if x ) = 255</li>
</ol>
<h3 id="ssim-component">SSIM component</h3>
<p>There are three comparison measuremtent between the reference image (x) and the test image (y) in the SSIM algorithm: Luminance (l), Contrast (c), structure (s):
$$
l(x,y) = \frac{2μ{_x}μ{_y}+(c{_1}L)^2}{ μ{_x}^2+ μ{_y}^2+(c{_1}L)^2}, \quad c(x,y) = \frac{2σ{_x}σ{_y}+(c{_2}L)^2}{σ{_x}^2+σ{_y}^2+(c{_2}L)^2}, \quad s(x,y) = \frac{σ{_x}{_y}+(c{_3}L)^2}{σ{_x}σ{_y}+(c{_3}L)^2}
$$
SSIM is the weighted combination of these three components, by setting their weights to the same, the SSIM formula the can be simplified to the form shown above.</p>
<h3 id="ssim-code">SSIM code</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-matlab" data-lang="matlab"><span style="display:flex;"><span>clear; close all; clc;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ReferenceImage = imread(<span style="color:#e6db74">&#39;reference.jpg&#39;</span>);
</span></span><span style="display:flex;"><span>TestImage = imread(<span style="color:#e6db74">&#39;test.jpg&#39;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">% Set the size of Test Image equal to Reference Image</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">% ================================================================</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>TestRow = size(TestImage,<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>TestColumn = size(TestImage,<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>TestRow_modified = size(ReferenceImage, <span style="color:#ae81ff">1</span>); 
</span></span><span style="display:flex;"><span>TestColumn_modified = size(ReferenceImage, <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">% Create (x,y) pairs for each point in the image and define its coordinate </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">% X-axis: the number of column / Y-axis: the number of row </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">% [ column, row ] = meshgrid( 1 : column, 1 : row ) </span>
</span></span><span style="display:flex;"><span>[n1, m1] = meshgrid(<span style="color:#ae81ff">1</span> : TestColumn_modified, <span style="color:#ae81ff">1</span> : TestRow_modified);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">% Let Sm = m / m&#39; and let m = m&#39; * Sm for m = 1,...,m&#39;     </span>
</span></span><span style="display:flex;"><span>Sm = TestRow <span style="color:#f92672">/</span> TestRow_modified; m1 = m1 <span style="color:#f92672">*</span> Sm;
</span></span><span style="display:flex;"><span><span style="color:#75715e">% Let Sn = n / n&#39; Let nf = c&#39; * Sn for n = 1,...,n&#39;</span>
</span></span><span style="display:flex;"><span>Sn = TestColumn <span style="color:#f92672">/</span> TestColumn_modified; n1 = n1 <span style="color:#f92672">*</span> Sn;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">% Let m = round(m1) and n = round(n1)</span>
</span></span><span style="display:flex;"><span>m = round(m1);
</span></span><span style="display:flex;"><span>n = round(n1);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#75715e">% Setting the values out of range </span>
</span></span><span style="display:flex;"><span>m(m <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span>) = <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>n(n <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span>) = <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>m(m <span style="color:#f92672">&gt;</span> TestRow <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) = TestRow <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>n(n <span style="color:#f92672">&gt;</span> TestColumn <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) = TestColumn <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">% Setting delta_m = m1 - m, delta_n = n1 - n</span>
</span></span><span style="display:flex;"><span>delta_m = m1 <span style="color:#f92672">-</span> m;
</span></span><span style="display:flex;"><span>delta_n = n1 <span style="color:#f92672">-</span> n;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">% Get indices for each point we wish to access</span>
</span></span><span style="display:flex;"><span>Test1_index = sub2ind([TestRow, TestColumn], m, n);
</span></span><span style="display:flex;"><span>Test2_index = sub2ind([TestRow, TestColumn], m<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, n);
</span></span><span style="display:flex;"><span>Test3_index = sub2ind([TestRow, TestColumn], m, n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>Test4_index = sub2ind([TestRow, TestColumn], m<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);       
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">% Interpolate: Go through each channel for the case of colour</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">% Create output image that is the same class as input</span>
</span></span><span style="display:flex;"><span>ModifiedTestImage = zeros(TestRow_modified, TestColumn_modified, size(TestImage, <span style="color:#ae81ff">3</span>));
</span></span><span style="display:flex;"><span>ModifiedTestImage = cast(ModifiedTestImage, class(TestImage));
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> index = <span style="color:#ae81ff">1</span> : size(TestImage, <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">% Get i&#39;th channel to get its color matrix</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    channel = double(TestImage(:,:,index)); 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">% Interpolate the channel</span>
</span></span><span style="display:flex;"><span>    tmp = channel(Test1_index) <span style="color:#f92672">.*</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> delta_m) <span style="color:#f92672">.*</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> delta_n) <span style="color:#f92672">+</span> <span style="color:#75715e">...</span>
</span></span><span style="display:flex;"><span>          channel(Test2_index) <span style="color:#f92672">.*</span> (delta_m) <span style="color:#f92672">.*</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> delta_n) <span style="color:#f92672">+</span> <span style="color:#75715e">...</span>
</span></span><span style="display:flex;"><span>          channel(Test3_index) <span style="color:#f92672">.*</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> delta_m) <span style="color:#f92672">.*</span> (delta_n) <span style="color:#f92672">+</span> <span style="color:#75715e">...</span>
</span></span><span style="display:flex;"><span>          channel(Test4_index) <span style="color:#f92672">.*</span> (delta_m) <span style="color:#f92672">.*</span> (delta_n);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    ModifiedTestImage(:,:,index) = cast(tmp, class(TestImage));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">% Implement the algorithm of SSIM </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">% ===============================================================</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>c1 = input(<span style="color:#e6db74">&#39;c1: &#39;</span>); <span style="color:#75715e">% recommand: c1 = 0.01</span>
</span></span><span style="display:flex;"><span>c2 = input(<span style="color:#e6db74">&#39;c2: &#39;</span>); <span style="color:#75715e">% recommand: c2 = 0.03</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">% if size(image,3) == 1, then the image is gray scale</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">% convert the image to double-precision array directly</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> size(ReferenceImage,<span style="color:#ae81ff">3</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>            
</span></span><span style="display:flex;"><span>    x = double(ReferenceImage); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> size(ModifiedTestImage,<span style="color:#ae81ff">3</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>            
</span></span><span style="display:flex;"><span>    y = double(ModifiedTestImage); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">% if size(image,3) == 1, then the image is gray scale</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">% convert the image from RGB to YCbCr to get luminance </span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> size(ReferenceImage,<span style="color:#ae81ff">3</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span>   
</span></span><span style="display:flex;"><span>    ReferenceImage_new = rgb2ycbcr(ReferenceImage);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">% the luminance component is in the first array</span>
</span></span><span style="display:flex;"><span>    LuminanceReference = ReferenceImage_new(:,:,<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">% then convert the image to double-precision array </span>
</span></span><span style="display:flex;"><span>    x = double(LuminanceReference);  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> size(ModifiedTestImage,<span style="color:#ae81ff">3</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span>   
</span></span><span style="display:flex;"><span>    TestImage_new = rgb2ycbcr(ModifiedTestImage);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">% the luminance component is in the first array</span>
</span></span><span style="display:flex;"><span>    LuminanceTest = TestImage_new(:,:,<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">% then convert the image to double-precision array  </span>
</span></span><span style="display:flex;"><span>    y = double(LuminanceTest);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>mean_x = sum(sqrt( x(:)<span style="color:#f92672">.*</span>x(:) )) <span style="color:#f92672">/</span> prod(size(x));
</span></span><span style="display:flex;"><span>mean_y = sum(sqrt( y(:)<span style="color:#f92672">.*</span>y(:) )) <span style="color:#f92672">/</span> prod(size(y));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Xdiff = x <span style="color:#f92672">-</span> mean_x;
</span></span><span style="display:flex;"><span>variance_x = sqrt( sum( Xdiff(:)<span style="color:#f92672">.*</span>Xdiff(:) ) <span style="color:#f92672">/</span> prod(size(x) ) );
</span></span><span style="display:flex;"><span>Ydiff = y <span style="color:#f92672">-</span> mean_y;
</span></span><span style="display:flex;"><span>variance_y = sqrt( sum( Ydiff(:)<span style="color:#f92672">.*</span>Ydiff(:) ) <span style="color:#f92672">/</span> prod(size(y) ) );
</span></span><span style="display:flex;"><span>variance_xy = sum( Xdiff(:)<span style="color:#f92672">.*</span>Ydiff(:) ) <span style="color:#f92672">/</span> prod(size(x) );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>L = <span style="color:#ae81ff">255</span>;
</span></span><span style="display:flex;"><span>Component1 = ( <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>mean_x<span style="color:#f92672">*</span>mean_y <span style="color:#f92672">+</span> (c1<span style="color:#f92672">*</span>L)^<span style="color:#ae81ff">2</span> ) <span style="color:#f92672">/</span> ( mean_x^<span style="color:#ae81ff">2</span><span style="color:#f92672">+</span>mean_y^<span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> (c1<span style="color:#f92672">*</span>L)^<span style="color:#ae81ff">2</span> ); 
</span></span><span style="display:flex;"><span>Component2 = ( <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>variance_xy <span style="color:#f92672">+</span> (c2<span style="color:#f92672">*</span>L)^<span style="color:#ae81ff">2</span> ) <span style="color:#f92672">/</span> ( variance_x^<span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> variance_y^<span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> (c2<span style="color:#f92672">*</span>L)^<span style="color:#ae81ff">2</span> );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>imshow(ReferenceImage)
</span></span><span style="display:flex;"><span>imshow(ModifiedTestImage)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>luminance_component = ( <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>mean_x<span style="color:#f92672">*</span>mean_y <span style="color:#f92672">+</span> (c1<span style="color:#f92672">*</span>L)^<span style="color:#ae81ff">2</span> ) <span style="color:#f92672">/</span> ( mean_x^<span style="color:#ae81ff">2</span><span style="color:#f92672">+</span>mean_y^<span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> (c1<span style="color:#f92672">*</span>L)^<span style="color:#ae81ff">2</span> ) 
</span></span><span style="display:flex;"><span>contrast_component = ( <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>variance_xy <span style="color:#f92672">+</span> (c2<span style="color:#f92672">*</span>L)^<span style="color:#ae81ff">2</span> ) <span style="color:#f92672">/</span> ( variance_x^<span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> variance_y^<span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> (c2<span style="color:#f92672">*</span>L)^<span style="color:#ae81ff">2</span> )
</span></span><span style="display:flex;"><span>SSIM = Component1<span style="color:#f92672">*</span>Component2
</span></span></code></pre></div><h3 id="benchmark-analysis">Benchmark Analysis</h3>
<p>Here are 8 pictures photographed using the same scene. Each picture has the same luminance and structure but different contrast information. By setting luminance and structure parameters of the reference and the test image to an approximate identity, we can use the SSIM index to objectively compare the contrast quality between them.</p>
<p><img src="/images/post/1.jpg" alt="1.jpg">contrast+80 (image 1)</p>
<p><img src="/images/post/2.jpg" alt="2.jpg">contrast+60 (image 2)</p>
<p><img src="/images/post/3.jpg" alt="3.jpg">contrast+40 (image 3)</p>
<p><img src="/images/post/4.jpg" alt="4.jpg">contrast+20 (image 4)</p>
<p><img src="/images/post/5.jpg" alt="5.jpg">contrast 0 (image 5)</p>
<p><img src="/images/post/6.jpg" alt="6.jpg">contrast-20 (image 6)</p>
<p><img src="/images/post/7.jpg" alt="7.jpg">contrast-40 (image 7)</p>
<p><img src="/images/post/8.jpg" alt="8.jpg">contrast-60 (image 8)</p>
<p><img src="/images/post/9.jpg" alt="9.jpg">contrast-60 (image 9)</p>
<h3 id="benchmark-analysis-result">Benchmark Analysis Result</h3>
<p>Because &ldquo;image 5&rdquo; (contrast 0) seems like the picture with the greatest contrast for our human visual system, let&rsquo;s take &ldquo;image 5&rdquo; (contrast 0) as the reference image for this SSIM benchmark analysis.</p>
<p>In order to rank each picture&rsquo;s contrast quality, this project is assessed and benchmarked by SSIM index.</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center"></th>
          <th style="text-align: center">1 vs 5</th>
          <th style="text-align: center">2 vs 5</th>
          <th style="text-align: center">3 vs 5</th>
          <th style="text-align: center">4 vs 5</th>
          <th style="text-align: center">6 vs 5</th>
          <th style="text-align: center">7 vs 5</th>
          <th style="text-align: center">8 vs 5</th>
          <th style="text-align: center">9 vs 5</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">l(x,y)</td>
          <td style="text-align: center">0.9995</td>
          <td style="text-align: center">0.9997</td>
          <td style="text-align: center">0.9998</td>
          <td style="text-align: center">1.0000</td>
          <td style="text-align: center">1.0000</td>
          <td style="text-align: center">0.9999</td>
          <td style="text-align: center">0.9997</td>
          <td style="text-align: center">0.9996</td>
      </tr>
      <tr>
          <td style="text-align: center">c(x,y)</td>
          <td style="text-align: center">0.9473</td>
          <td style="text-align: center">0.9669</td>
          <td style="text-align: center">0.9832</td>
          <td style="text-align: center">0.9946</td>
          <td style="text-align: center">0.9937</td>
          <td style="text-align: center">0.9773</td>
          <td style="text-align: center">0.9468</td>
          <td style="text-align: center">0.9017</td>
      </tr>
      <tr>
          <td style="text-align: center">SSIM</td>
          <td style="text-align: center">0.9468</td>
          <td style="text-align: center">0.9665</td>
          <td style="text-align: center">0.9831</td>
          <td style="text-align: center">0.9946</td>
          <td style="text-align: center">0.9936</td>
          <td style="text-align: center">0.9772</td>
          <td style="text-align: center">0.9465</td>
          <td style="text-align: center">0.9013</td>
      </tr>
  </tbody>
</table>
<p>Based on the data shown above, we can assume that the contrast quality ranking, from good to bad, becomes image 4, 6, 3, 7, 2, 1, 8, 5.</p>
<p><img src="/images/post/SSIMplot.jpg" alt=""></p>
<h3 id="ssim-disadvantages">SSIM disadvantages</h3>
<p>SSIM is limited when the images has unstructured distortion. It is <strong>sensitive to image rotations and image translations.</strong> If we are using SSIM index for competitor analysis and trying to compare images where <strong>both camera&rsquo;s FOV (field of view) are slightly different</strong>, then it&rsquo;ll leads to erroneous image quality measurements.</p>

                        </div>
                    </div>
                </div>
            </div>
        </section>

        

        

        <section class="section">
            <div class="container is-max-desktop">
                <h2 class="title is-3 has-text-centered">Key Findings</h2>
                <div class="content">
                    <div class="columns is-multiline">
                        <div class="column is-half">
                            <div class="card-container" style="height: 100%;">
                                <h4 class="title is-5">ColorChecker® Application</h4>
                                <p>The ColorChecker® Patch Classic target provides a standard for:</p>
                                <ul>
                                    <li>Camera calibration in image color accuracy</li>
                                    <li>Auto white balance evaluation</li>
                                    <li>Accurate calculation of ΔE* and ΔC* metrics</li>
                                </ul>
                            </div>
                        </div>
                        <div class="column is-half">
                            <div class="card-container" style="height: 100%;">
                                <h4 class="title is-5">Algorithm Differences</h4>
                                <p>Major differences between software implementations:</p>
                                <ul>
                                    <li>Chromatic adaptation methods (D50 vs D65)</li>
                                    <li>Coordinate systems (rectangular vs polar)</li>
                                    <li>Formula variations (CIE 1976 vs CIE 2000)</li>
                                </ul>
                            </div>
                        </div>
                        <div class="column is-half">
                            <div class="card-container" style="height: 100%;">
                                <h4 class="title is-5">Imatest Implementation</h4>
                                <p>Key characteristics of Imatest's approach:</p>
                                <ul>
                                    <li>Uses D65XYZ without D50 chromatic adaptation</li>
                                    <li>Employs rectangular coordinate system</li>
                                    <li>ΔC* calculated from a* and b* differences</li>
                                </ul>
                            </div>
                        </div>
                        <div class="column is-half">
                            <div class="card-container" style="height: 100%;">
                                <h4 class="title is-5">iQ-Analyzer Implementation</h4>
                                <p>Key characteristics of iQ-Analyzer's approach:</p>
                                <ul>
                                    <li>Applies Bradford matrix for D50 adaptation</li>
                                    <li>Uses polar coordinate system</li>
                                    <li>ΔC* can have negative values</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section class="section hero is-light">
            <div class="container is-max-desktop">
                <div class="columns is-centered">
                    <div class="column is-four-fifths">
                        <h2 class="title is-3 has-text-centered">Methodology</h2>
                        <div class="content has-text-justified">
                            <h4 class="title is-5">Color Space Conversion</h4>
                            <p>
                                The conversion from RGB to Lab color space requires an intermediate transformation through XYZ color space. The process involves:
                            </p>
                            <ol>
                                <li><strong>RGB to XYZ:</strong> Using the standard RGB2XYZ transformation matrix (M1)</li>
                                <li><strong>Chromatic Adaptation:</strong> Applying Bradford matrix (M2) for D50 adaptation when required</li>
                                <li><strong>XYZ to Lab:</strong> Final conversion to perceptually uniform Lab space</li>
                            </ol>

                            <h4 class="title is-5">Color Difference Metrics</h4>
                            <p>Two main standards for calculating color differences:</p>
                            <ul>
                                <li><strong>CIE 1976 (ΔE*ab):</strong> Simple Euclidean distance in Lab space</li>
                                <li><strong>CIE 2000 (ΔE*00):</strong> Advanced formula with weighting factors and rotational terms</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section class="section">
            <div class="container is-max-desktop">
                <div class="columns is-centered has-text-centered">
                    <div class="column is-four-fifths">
                        <h2 class="title is-3">Research Impact</h2>
                        <div class="content has-text-justified">
                            <p>This research provides crucial insights for:</p>
                            <ul>
                                <li>Camera manufacturers developing automated image quality testing systems</li>
                                <li>Engineers implementing color difference algorithms</li>
                                <li>Researchers comparing results across different analysis platforms</li>
                                <li>Quality assurance teams selecting appropriate software tools</li>
                            </ul>
                            <p>
                                Understanding these algorithmic differences enables more accurate cross-platform comparisons and informed software selection for specific image quality assessment needs.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section class="section hero is-light" id="BibTeX">
            <div class="container is-max-desktop content">
                <h2 class="title is-3 has-text-centered">BibTeX</h2>
                <pre><code>@article{ChromaDifference2023,
  title={ PSNR and SSIM },
  author={ Neil Lee },
  year={2023},
  url={ http://localhost:59073/research/psnrvsssim/ }
}</code></pre>
            </div>
        </section>

        <section class="section">
            <div class="container is-max-desktop">
                <div class="columns is-centered has-text-centered">
                    <div class="column is-four-fifths">
                        <h2 class="title is-3">Acknowledgements</h2>
                        <div class="content">
                            <p>
                                This study represents the findings and results of a collaborative effort conducted with Allen Tsou in 2023.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <footer class="footer">
            <div class="container">
                <div class="columns is-centered">
                    <div class="column is-8">
                        <div class="content has-text-centered">
                            <p>
                                This page was built using the <a href="https://github.com/eliahuhorwitz/Academic-project-page-template" target="_blank">Academic Project Page Template</a>.
                                <br />This website is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </footer>
    </body>
</html>
